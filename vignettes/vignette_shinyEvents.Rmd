---
title: "shinyEvents Vignette"
author: "Sebastian Kranz"
date: "Sunday, January 11, 2015"
output:
  html_document:
    keep_md: yes
---

## Brief Summary

The shinyEvents package allows to write shiny applications that use classical event handlers, e.g. for button clicks, value changes, etc, instead of reactive programming. One does not write an explicit server function, but just adds event handlers to an `app` object. Widgets will be updated with explicit calls to setXXXX functions, like e.g. `setText(id, "New text")`. Widget values and event handlers can be set in a similar fashion for an app that has not yet started as for an already running app. 

## Installation

To install the package see the description on the package's Github page:

https://github.com/skranz/shinyEvents

## Motivation

RStudio's shiny is a great framework to generate web applications with R. In a classical shiny app, interactivity is not generated via event handlers but by `reactive programming`. For details, see the shiny documentation and tutorials under http://shiny.rstudio.com/.

While shiny's reactive programming model is great for smaller apps, I personally found it less useful for bigger applications that create a lot of interactive dynamic UI.

For example, when writing the initial shiny interface for my package RTutor (https://github.com/skranz/RTutor), I felt that some observers or render functions were triggered too frequently, and I was not sure where to best put the 'server code' of newly dynamically created objects. Of course, one it is possible to write large applications with reactivity, but given my limited understanding of the reactivity model, it just was hard for me...

Anyway, I generated the package `shinyEvents` to emulate the classical event-handling paradigm for shiny applications and find it useful, at least for my own shiny projects. 


## Examples

### A simple static app

Here is a simple example app. 
```{r eval=FALSE}
library(shinyEvents)

# Create a new eventsApp
app = eventsApp()

# ui
app$ui = fluidPage(
  actionButton("plotBtn", "plot"),
  selectInput("mySelect", "Select:",
      c("Cylinders" = "cyl",
        "Transmission" = "am",
        "Gears" = "gear")
  ),
  textOutput("myText"),
  plotOutput("myPlot")
)

# Handler for the plot button
buttonHandler("plotBtn", function(session, id, value, app,...) {
  setText("myText", paste0("You pressed the button ",id," ", value," times. "))
  setPlot("myPlot", plot(runif(10), runif(10)))    
})

# Handler for change of an input value
changeHandler("mySelect", function(id, value,...) {
  setText("myText",paste0("You chose the list item ", value,". ", 
                          "A random number: ", sample(1:1000,1)))
})

# Set an initial text
setText("myText","This is the start text...")

# Directly launch the events app in the viewer pane
runEventsApp(app,launch.browser=rstudio::viewer)
```

Note that a call to `eventsApp()` stores the generated app object (an environment) globally. The calls to buttonHandler, changeHandler and setText reference by default to this globally stored app object. Once the app starts, a copy of the app object will be generated for each user session that is generated by shiny.

Such a simple app app could be much easier written with the standard reactivity model of shiny. In my view shinyEvents becomes more useful when you have an app that creates a lot of dynamic UI.

## A simple dynamic app

Here is a simple dynamic app.
```{r eval=FALSE}
# Create a new eventsApp
app = eventsApp()

# main ui
app$ui = fluidPage(
  actionButton("uiBtn", "make dynamic ui"),
  textOutput("myText"),
  uiOutput('myUI')
)

# Dynamically create UI with button and add handler for it
buttonHandler("uiBtn", function(session, value,...) {  
  # Set a new dynamic UI
  dynUI= fluidRow(
    actionButton("dynBtn", paste0("Dynamic button ",value))
  )
  setUI("myUI", dynUI)
  
  # Add handler for the new dynBtn in the new UI.
  # Existing handlers for dynBtn are by default replaced
  buttonHandler("dynBtn", ui.count = value, function(value,ui.count,...) {
    setText("myText", paste0(
      "UI was created ", ui.count, " times.\n",
      "Dynamic button pressed ", value, " times."))
  })
})
# Directly launch the events app in the viewer pane
runEventsApp(app,launch.browser=rstudio::viewer)
```

The button handler for the static button creates and sets a new UI with another button and also generates a handler for the new button. 

Note:

  - The syntax for creating handlers (and setting values) stays the same for dynamic objects created by an already running app as for static objects that are created before the app has started.
  
  - The dynamically created button Handler
  `buttonHandler("dynBtn", ui.count = value, function(value,ui.count...) {`
passes a manual parameter ui.count to the handler function.
